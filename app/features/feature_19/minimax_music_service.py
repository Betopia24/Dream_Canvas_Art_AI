import logging
import os
import requests
from datetime import datetime
import fal_client
from core.config import config

logger = logging.getLogger(__name__)

class MinimaxMusicService:
    """Service for generating music using MiniMax Music from FAL.ai"""
    
    def __init__(self):
        self.api_key = config.FAL_API_KEY
        if not self.api_key:
            raise ValueError("FAL_API_KEY is required in .env file")
        
        # Configure FAL client
        os.environ["FAL_KEY"] = self.api_key
        fal_client.api_key = self.api_key
        
        self.audio_folder = "generated_audio"
        # Create the folder if it doesn't exist
        os.makedirs(self.audio_folder, exist_ok=True)
        
    async def generate_audio(self, verse_prompt: str, theme_prompt: str) -> str:
        """
        Generate audio using MiniMax Music and save it locally
        
        Args:
            verse_prompt (str): The verse/main content prompt
            theme_prompt (str): The lyrical/instrumental theme prompt
            
        Returns:
            str: Local audio URL
        """
        try:
            logger.info(f"Generating music with MiniMax for verse: {verse_prompt[:50]}... and theme: {theme_prompt[:50]}...")
            
            # Submit the request to FAL.ai
            handler = fal_client.submit(
                "fal-ai/minimax-music/v1.5",
                arguments={
                    "prompt": verse_prompt,
                    "theme": theme_prompt
                }
            )
            
            # Get the result
            result = handler.get()
            
            if not result or "audio" not in result or not result["audio"]:
                raise Exception("No audio generated by FAL.ai")
            
            # Get the audio URL
            audio_url = result["audio"]["url"]
            
            # Download and save the audio locally
            local_audio_url = await self._download_and_save_audio(audio_url, verse_prompt, theme_prompt)
            
            logger.info(f"Successfully generated audio")
            return local_audio_url
            
        except Exception as e:
            logger.error(f"Error generating audio: {str(e)}")
            raise
    
    async def _download_and_save_audio(self, audio_url: str, verse_prompt: str, theme_prompt: str) -> str:
        """
        Download audio from URL and save it locally
        
        Args:
            audio_url (str): URL of the generated audio
            verse_prompt (str): Original verse prompt (for filename)
            theme_prompt (str): Original theme prompt (for filename)
            
        Returns:
            str: Local audio URL
        """
        try:
            # Create a safe filename
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            safe_verse = "".join(c for c in verse_prompt[:20] if c.isalnum() or c in (' ', '-', '_')).rstrip()
            safe_verse = safe_verse.replace(' ', '_')
            safe_theme = "".join(c for c in theme_prompt[:20] if c.isalnum() or c in (' ', '-', '_')).rstrip()
            safe_theme = safe_theme.replace(' ', '_')
            filename = f"minimax_music_{timestamp}_{safe_verse}_{safe_theme}.mp3"
            
            # Full path for the audio
            file_path = os.path.join(self.audio_folder, filename)
            
            # Download the audio
            response = requests.get(audio_url)
            response.raise_for_status()
            
            # Save the audio
            with open(file_path, 'wb') as f:
                f.write(response.content)
            
            # Return URL
            local_audio_url = f"{config.BASE_URL}/audio/{filename}"
            
            logger.info(f"Audio saved to: {file_path}")
            logger.info(f"Audio URL: {local_audio_url}")
            return local_audio_url
            
        except Exception as e:
            logger.error(f"Error downloading and saving audio: {str(e)}")
            raise

# Create a singleton instance
minimax_music_service = MinimaxMusicService()
